<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ZpDIC操作・派生ツール完全版</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f5f5f5;
    }
    input, textarea, select, button {
      display: block;
      margin: 8px 0;
      padding: 6px;
      width: 100%;
      max-width: 500px;
    }
    textarea {
      height: 80px;
    }
    pre {
      background: #fff;
      padding: 10px;
      max-width: 800px;
      overflow: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    h2 {
      margin-top: 30px;
    }
    #progressBarWrapper {
      width: 100%;
      max-width: 500px;
      background: #ddd;
      height: 20px;
      margin: 8px 0;
    }
    #progressBar {
      height: 100%;
      width: 0%;
      background: #4caf50;
      transition: width 0.4s;
    }
  </style>
</head>
<body>
<h1>ZpDIC 操作＆派生ツール</h1>

<label>APIキー:</label><input id="apiKey" autocomplete="off" spellcheck="false">
<label>搬入口辞書ID:</label><input id="inputDict" autocomplete="off" spellcheck="false">
<label>搬出口辞書ID:</label><input id="outputDict" autocomplete="off" spellcheck="false">

<hr><h2>🔹 単語派生設定</h2>
<textarea id="derivationRules" placeholder="d→t\na→e など改行区切り"></textarea>
<input id="rulesetName" placeholder="ルールセット名" autocomplete="off" spellcheck="false">
<button onclick="saveRuleset()">ルールセット保存</button>
<select id="rulesetSelect" size="5" style="max-width: 250px;"></select>
<button onclick="loadRuleset()">選択呼び出し</button>
<button onclick="deleteRuleset()">選択削除</button>

<label>単語番号範囲（例: 1-500）:</label>
<input id="wordRange" autocomplete="off" spellcheck="false">

<label>クールダウン時間（秒、デフォルト6.0秒）:</label>
<input id="cooldown" type="number" min="0" step="0.1" value="6.0" style="width:120px;" autocomplete="off" spellcheck="false">

<button onclick="runDerivation()">派生開始</button>
<div id="progressBarWrapper"><div id="progressBar"></div></div>
<pre id="progress"></pre>

<hr><h2>🔧 単語編集・検索</h2>
<input id="editWordNumber" placeholder="単語番号（新規は空）" autocomplete="off" spellcheck="false">
<input id="editWordName" placeholder="単語名" autocomplete="off" spellcheck="false">
<input id="editPronunciation" placeholder="発音" autocomplete="off" spellcheck="false">
<input id="editVariations" placeholder="変化形(|区切り)" autocomplete="off" spellcheck="false">
<input id="editTags" placeholder="タグ(|区切り)" autocomplete="off" spellcheck="false">
<textarea id="editInformations" placeholder="情報 タイトル|内容 改行区切り"></textarea>
<button onclick="submitWord()">保存</button>
<button onclick="deleteWord()">削除</button>
<button onclick="loadWord()">読み込み</button>
<pre id="wordResult"></pre>

<h3>🔎 単語検索</h3>
<input id="searchText" placeholder="検索語" autocomplete="off" spellcheck="false">
<select id="searchMode">
  <option value="both">単語＋訳語</option>
  <option value="name">単語名</option>
  <option value="information">内容</option>
  <option value="variation">変化形</option>
</select>
<button onclick="searchWords()">検索</button>
<pre id="searchResult"></pre>

<script>
const apiBase = 'https://zpdic.ziphil.com/api/v0';
function getHeaders() {
  return {
    'Content-Type': 'application/json',
    'X-Api-Key': document.getElementById('apiKey').value
  };
}

function saveRuleset() {
  const name = document.getElementById('rulesetName').value.trim();
  if (!name) return alert('名前が必要です');
  const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const existing = sets.find(s => s.name === name);
  if (existing) existing.rules = rules;
  else sets.push({ name, rules });
  localStorage.setItem('derivationRulesets', JSON.stringify(sets));
  alert('保存完了');
  renderRulesets();
}
function renderRulesets() {
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const sel = document.getElementById('rulesetSelect');
  sel.innerHTML = '';
  sets.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.name;
    opt.textContent = s.name;
    sel.appendChild(opt);
  });
}
function loadRuleset() {
  const sel = document.getElementById('rulesetSelect');
  if (!sel.value) return alert('ルールセットを選択してください');
  const sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  const found = sets.find(s => s.name === sel.value);
  if (found) document.getElementById('derivationRules').value = found.rules.join('\n');
}
function deleteRuleset() {
  const sel = document.getElementById('rulesetSelect');
  if (!sel.value) return alert('ルールセットを選択してください');
  let sets = JSON.parse(localStorage.getItem('derivationRulesets') || '[]');
  sets = sets.filter(s => s.name !== sel.value);
  localStorage.setItem('derivationRulesets', JSON.stringify(sets));
  renderRulesets();
}
function applyRules(text, rules) {
  let res = text;
  for (const rule of rules) {
    const [from, to] = rule.split('→').map(s => s.trim());
    if (from) res = res.replace(new RegExp(from, 'g'), to);
  }
  return res;
}
function updateProgressBar(completed, total) {
  const percent = Math.floor((completed / total) * 100);
  document.getElementById('progressBar').style.width = percent + '%';
  document.getElementById('progress').textContent = `${completed} / ${total} 派生完了`;
}

async function runDerivation() {
  const inId = document.getElementById('inputDict').value.trim();
  const outId = document.getElementById('outputDict').value.trim();
  const range = document.getElementById('wordRange').value.trim();
  if (!range.includes('-')) return alert('単語番号範囲を正しく入力してください（例: 1-500）');
  const [start, end] = range.split('-').map(Number);
  if (isNaN(start) || isNaN(end) || start > end) return alert('範囲が不正です');

  const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);
  let cooldown = parseFloat(document.getElementById('cooldown').value);
  if (isNaN(cooldown) || cooldown < 0) cooldown = 6.0;

  let retryList = [];
  let totalCount = end - start + 1;
  let completedCount = 0;
  let allIndices = [];
  for (let i = start; i <= end; i++) allIndices.push(i);

  async function delay(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  async function fetchWord(i) {
    const res = await fetch(`${apiBase}/dictionary/${inId}/word/${i}`, { headers: getHeaders() });
    if (!res.ok) throw new Error(`単語取得失敗: ${i}`);
    return (await res.json()).word;
  }

  function transformWord(w) {
    let equivalents = w.equivalents || [];
    let informations = (w.informations || []).filter(inf => {
      const titleLower = (inf.title || '').toLowerCase();
      const textLower = (inf.text || '').toLowerCase();
      if (titleLower.includes('訳語') || textLower.includes('訳語')) {
        let text = inf.text || '';
        const match = text.match(/訳語[:：]?\s*(.+)/);
        if (match && match[1]) {
          const words = match[1].split(/[,、\s]+/).map(s => s.trim()).filter(Boolean);
          words.forEach(wrd => {
            if (!equivalents.find(e => e.name === wrd)) {
              equivalents.push({ name: wrd });
            }
          });
        } else {
          if (!equivalents.find(e => e.name === text)) {
            equivalents.push({ name: text });
          }
        }
        return false;
      }
      return true;
    });

    return {
      word: {
        name: applyRules(w.name, rules),
        pronunciation: applyRules(w.pronunciation || '', rules),
        equivalents: equivalents,
        tags: w.tags,
        informations: informations.map(inf => ({
          title: applyRules(inf.title, rules),
          text: applyRules(inf.text, rules)
        })),
        variations: w.variations,
        relations: w.relations
      }
    };
  }

  async function postWords(words) {
    const res = await fetch(`${apiBase}/dictionary/${outId}/words`, {
      method: 'POST',
      headers: getHeaders(),
      body: JSON.stringify({ words })
    });
    if (!res.ok) throw new Error(`一括登録失敗 状態コード ${res.status}`);
  }

  for (let i = 0; i < allIndices.length; i += 10) {
    const batch = allIndices.slice(i, i + 10);
    const wordData = [];
    for (const idx of batch) {
      try {
        const original = await fetchWord(idx);
        wordData.push(transformWord(original).word);
      } catch (e) {
        console.error(e);
        retryList.push(idx);
      }
    }
    if (wordData.length > 0) {
      try {
        await postWords(wordData);
        completedCount += wordData.length;
        updateProgressBar(completedCount, totalCount);
      } catch (e) {
        console.error(e);
        retryList.push(...batch);
      }
    }
    await delay(cooldown * 1000);
  }

  if (retryList.length > 0) {
    alert(`⚠️ 一部の単語は処理できませんでした: ${retryList.join(', ')}`);
  } else {
    alert('✅ 派生処理完了');
  }
}
</script>
</body>
</html>
