<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ZpDIC操作・派生ツール完全版</title>
  <style>
    body { font-family: sans-serif; margin: 20px; background: #f5f5f5; }
    input, textarea, select, button { display: block; margin: 8px 0; padding: 6px; width: 100%; max-width: 500px; }
    textarea { height: 80px; }
    pre { background: #fff; padding: 10px; max-width: 800px; overflow: auto; white-space: pre-wrap; word-wrap: break-word; }
    h2 { margin-top: 30px; }
    #progressBar { width: 100%; max-width: 500px; height: 20px; background: #ccc; margin-top: 5px; }
    #progressFill { height: 100%; width: 0%; background: #4caf50; transition: width 0.3s ease; }
  </style>
</head>
<body>
  <h1>ZpDIC 操作＆派生ツール</h1>
  <label>APIキー:</label><input id="apiKey" autocomplete="off" spellcheck="false">
  <label>搬入口辞書ID:</label><input id="inputDict" autocomplete="off" spellcheck="false">
  <label>搬出口辞書ID:</label><input id="outputDict" autocomplete="off" spellcheck="false">

  <hr><h2>🔹 単語派生設定</h2>
  <textarea id="derivationRules" placeholder="d→t\na→e など改行区切り"></textarea>
  <input id="rulesetName" placeholder="ルールセット名" autocomplete="off" spellcheck="false">
  <button onclick="saveRuleset()">ルールセット保存</button>
  <select id="rulesetSelect" size="5" style="max-width: 250px;"></select>
  <button onclick="loadRuleset()">選択呼び出し</button>
  <button onclick="deleteRuleset()">選択削除</button>

  <label>単語番号範囲（例: 1-500）:</label>
  <input id="wordRange" autocomplete="off" spellcheck="false">
  <label>クールダウン時間（秒）:</label>
  <input id="cooldown" type="number" min="0" step="0.1" value="6.0" style="width:120px;">

  <button onclick="runDerivation()">派生開始</button>
  <pre id="progress"></pre>
  <div id="progressBar"><div id="progressFill"></div></div>

  <hr><h2>🔧 単語編集・検索</h2>
  <input id="editWordNumber" placeholder="単語番号（新規は空）">
  <input id="editWordName" placeholder="単語名">
  <input id="editPronunciation" placeholder="発音">
  <input id="editVariations" placeholder="変化形(|区切り)">
  <input id="editTags" placeholder="タグ(|区切り)">
  <textarea id="editInformations" placeholder="情報 タイトル|内容 改行区切り"></textarea>
  <button onclick="submitWord()">保存</button>
  <button onclick="deleteWord()">削除</button>
  <button onclick="loadWord()">読み込み</button>
  <pre id="wordResult"></pre>

  <h3>🔎 単語検索</h3>
  <input id="searchText" placeholder="検索語">
  <select id="searchMode">
    <option value="both">単語＋訳語</option>
    <option value="name">単語名</option>
    <option value="information">内容</option>
    <option value="variation">変化形</option>
  </select>
  <button onclick="searchWords()">検索</button>
  <pre id="searchResult"></pre>

  <script>
    const apiBase = 'https://zpdic.ziphil.com/api/v0';
    function getHeaders() {
      return {
        'Content-Type': 'application/json',
        'X-Api-Key': document.getElementById('apiKey').value
      };
    }

    function applyRules(text, rules) {
      let res = text;
      for (const rule of rules) {
        const [from, to] = rule.split('→').map(s => s.trim());
        if (from) res = res.replace(new RegExp(from, 'g'), to);
      }
      return res;
    }

    async function runDerivation() {
      const inId = document.getElementById('inputDict').value.trim();
      const outId = document.getElementById('outputDict').value.trim();
      const range = document.getElementById('wordRange').value.trim();
      const cooldown = parseFloat(document.getElementById('cooldown').value);
      const rules = document.getElementById('derivationRules').value.trim().split('\n').filter(Boolean);

      if (!range.includes('-')) return alert('単語番号範囲を正しく入力してください（例: 1-500）');
      const [start, end] = range.split('-').map(Number);
      if (isNaN(start) || isNaN(end) || start > end) return alert('範囲が不正です');

      const total = end - start + 1;
      let completed = 0;
      let retryList = [];

      function updateProgress() {
        document.getElementById('progress').textContent = `${completed} / ${total} 派生完了`;
        document.getElementById('progressFill').style.width = `${(completed / total) * 100}%`;
      }

      async function processBatch(ids) {
        await Promise.all(ids.map(async id => {
          try {
            const res = await fetch(`${apiBase}/dictionary/${inId}/word/${id}`, { headers: getHeaders() });
            if (!res.ok) throw new Error();
            const w = (await res.json()).word;

            let equivalents = w.equivalents || [];
            let informations = (w.informations || []).filter(inf => {
              const titleLower = (inf.title || '').toLowerCase();
              const textLower = (inf.text || '').toLowerCase();
              if (titleLower.includes('訳語') || textLower.includes('訳語')) {
                let text = inf.text || '';
                const match = text.match(/訳語[:：]?\s*(.+)/);
                if (match && match[1]) {
                  const words = match[1].split(/[,、\s]+/).map(s => s.trim()).filter(Boolean);
                  words.forEach(wrd => {
                    if (!equivalents.find(e => e.name === wrd)) {
                      equivalents.push({ name: wrd });
                    }
                  });
                } else {
                  if (!equivalents.find(e => e.name === text)) {
                    equivalents.push({ name: text });
                  }
                }
                return false;
              }
              return true;
            });

            const body = {
              word: {
                name: applyRules(w.name, rules),
                pronunciation: applyRules(w.pronunciation || '', rules),
                equivalents,
                tags: w.tags,
                informations: informations.map(inf => ({
                  title: applyRules(inf.title, rules),
                  text: applyRules(inf.text, rules)
                })),
                variations: w.variations,
                relations: w.relations
              }
            };

            const postRes = await fetch(`${apiBase}/dictionary/${outId}/word`, {
              method: 'POST',
              headers: getHeaders(),
              body: JSON.stringify(body)
            });
            if (!postRes.ok) throw new Error();
            completed++;
            updateProgress();
          } catch (e) {
            retryList.push(id);
          }
        }));
      }

      updateProgress();
      const allIds = Array.from({ length: total }, (_, i) => start + i);
      for (let i = 0; i < allIds.length; i += 10) {
        const batch = allIds.slice(i, i + 10);
        await processBatch(batch);
        await new Promise(r => setTimeout(r, cooldown * 1000));
      }

      let retryCount = 0;
      while (retryList.length > 0 && retryCount < 3) {
        const current = [...retryList];
        retryList = [];
        for (let i = 0; i < current.length; i += 10) {
          await processBatch(current.slice(i, i + 10));
          await new Promise(r => setTimeout(r, cooldown * 1000));
        }
        retryCount++;
      }

      if (retryList.length > 0) {
        alert(`⚠️ 一部の単語は失敗しました: ${retryList.join(', ')}`);
      } else {
        alert('✅ 派生完了');
      }
    }
  </script>
</body>
</html>
